# Sequlite Software Development Guide

This document contains best-practices and guidelines that will help keep the software repository organized and make it easier to see the history of changes made to the software.

## :dna: Summary

The github repository uses the GitFlow branching pattern and includes the following branches:

* **main**
  * The *main* branch is for production code and is only for pulling. Do not push to the *main* branch. Pull changes into your issue or development branch and submit changes to main with a pull request (PR). Changes to the *main* branch should only come from the *development* branch (after review) and the *hotfixes* branch (in an emergency).
* **hotfixes**
  * The *hotfixes* branch is where small and urgent changes should be made. Pull from the *main* branch and submit a PR to *main* with the changes.
* **development**
  * The *development* branch is where all new work should be placed. Submit changes to the *development* branch from an issue branch with a PR.
* **issue123**
  * Create an issue branch for each issue that requires work and commit changes here. When an issue is finished, submit a PR to the *development* branch. Issue branches can be deleted once the issue is closed.
* **issue456...**

## :hammer: Beginning Work on an Issue

1. Make sure that an issue exists in the tracker.
    1. If the issue does not exist, create the issue, assign the appropriate labels, and enter a brief summary of the issue.
    2. Try to keep titles succinct. Details can be elaborated in the issue summary.
2. Create a branch for the issue.
    3. Branch from the *development* branch.
    4. Name the branch following the format: `<issueNumber>-<issueTitle>` (example: 123-ImagingExceptionStopsRecipe)
3. Checkout the new branch that you created for this issue.
4. Commit changes to this branch as you work.
5. When the changes are complete and tested, submit a pull request (PR) to merge your issue branch into the *development* branch.
6. If the issue is not completed by the end of the work day or another issue needs immediate attention, make sure to commit WIP changes to your local issue branch before changing branches.

## :traffic_light: Resuming Work on an Issue

1. Checkout the issue branch.
2. Fetch and merge the latest changes from the *development* branch into your local issue branch.
3. Commit your changes as you work.

## :checkered_flag: Finishing Work on an Issue

1. Fetch and merge the latest changes from the *development* branch into your local issue branch.
    * Use your **issue branch** to resolve all merge conflicts and test to ensure your changes integrate niceley with the code.
2. Submit a pull request to the *development* branch.
3. After reviewing the changes, the issue branch can be pulled into the *development* branch and the issue branch can be deleted.

## :deciduous_tree: Crafting Good Commit Messages

1. Commit small and specific pieces of work. At a minimum, changes need to be stored in a commit at the end of the day.
2. Keep commit messages concise (~50 characters). The *commit summary* can be used to add details.
3. Write the commit message in the imperative tense (example: fix-motion control exception logic)
4. Prefix commit message with the type of the commit. All commits should be one of the following types:
    1. **build**: Changes that affect the build system or external dependencies
    2. **ci**: Changes to continuous integration configuration files and scripts
    3. **docs**: Documentation only changes
    4. **feat**: A new feature
    5. **fix**: A bug fix
    6. **perf**: A code change that improves performance
    7. **refactor**: A code change that neither fixes a bug nor adds a feature
    8. **test**: Adding missing tests or correcting existing tests

    Example commit messages: `test - add negative agrument test for image cropping`

## :label: Tagging a New Version

* In the source code, the version number is automatically generated during the build process. The file must be manually edited when a new major, minor, or patch version is released.
* Version number: `<major><minor><patch><build>`
  * The first three fields are edited manually
  * The last field (build) is automatically generated by the build process
* When to change the version number:
  * Changes are pulled into main. **Every commit on *main* should have a unique version number.**
  * Bugs have been fixed on the *development* branch
  * Changes have been made to Config.json or Calib.json files
  * Change have been made to OLA
* How to change the version number
  * Edit the file VersionTextTemplate.tt located at: `Libraries/Sequlite.ALF.Common/VersionTextTemplate.tt`
    * Change one or more of the first three fields of `AssemblyVersion` **and** `AssemblyFileVersion`
    * Example: to increment version 3.5.5 to version 3.5.6:
      * `[assembly: AssemblyVersion("3.5.5.<#= this.RevisionNumber #>")]` -> `[assembly: AssemblyVersion("3.5.6.<#= this.RevisionNumber #>")]`
      * `[assembly: AssemblyFileVersion("3.5.5.<#= this.RevisionNumber #>")]` -> `[assembly: AssemblyFileVersion("3.5.6.<#= this.RevisionNumber #>")]`

  * Commit changes, merge with a PR, and tag the commit with the new version
    * Create a tag
      * `git tag <tagname>`
      * Replace `tagname` with a semantic identifier to the state of the repo at the time the tag is being created. A common pattern is to use version numbers
      * Example: `git tag v3.5.6`
    * Push the new tag to the remote repository
      * `git push origin v3.5.6`
